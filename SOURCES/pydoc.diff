diff --git a/python/header-py.c b/python/header-py.c
index a8470ee..63167d9 100644
--- a/python/header-py.c
+++ b/python/header-py.c
@@ -347,31 +347,31 @@ static PyObject * hdr_reduce(hdrObject *s)
 
 static struct PyMethodDef hdr_methods[] = {
     {"keys",		(PyCFunction) hdrKeyList,	METH_NOARGS,
-	NULL },
+     "hdr.keys() -- Return a list of the header's rpm tags (int RPMTAG_*)." },
     {"unload",		(PyCFunction) hdrUnload,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+     "hdr.unload(legacyHeader=False) -- Return binary representation\nof the header." },
     {"expandFilelist",	(PyCFunction) hdrExpandFilelist,METH_NOARGS,
-	NULL },
+     "DEPRECATED -- Use hdr.convert() instead." },
     {"compressFilelist",(PyCFunction) hdrCompressFilelist,METH_NOARGS,
-	NULL },
+     "DEPRECATED -- Use hdr.convert() instead." },
     {"fullFilelist",	(PyCFunction) hdrFullFilelist,	METH_NOARGS,
-	NULL },
+     "DEPRECATED -- Obsolete method."},
     {"convert",		(PyCFunction) hdrConvert,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+     "hdr.convert(op=-1) -- Convert header - See HEADERCONV_*\nfor possible values of op."},
     {"format",		(PyCFunction) hdrFormat,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+     "hdr.format(format) -- Expand a query string with the header data.\n\nSee rpm -q for syntax." },
     {"sprintf",		(PyCFunction) hdrFormat,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+     "Alias for .format()." },
     {"isSource",	(PyCFunction)hdrIsSource,	METH_NOARGS, 
-	NULL },
+     "hdr.isSource() -- Return if header describes a source package." },
     {"write",		(PyCFunction)hdrWrite,		METH_VARARGS|METH_KEYWORDS,
-	NULL },
+     "hdr.write(file, magic=True) -- Write header to file." },
     {"dsOfHeader",	(PyCFunction)hdr_dsOfHeader,	METH_NOARGS,
-	NULL},
+     "hdr.dsOfHeader() -- Return dependency set with the header's NEVR."},
     {"dsFromHeader",	(PyCFunction)hdr_dsFromHeader,	METH_VARARGS|METH_KEYWORDS,
-	NULL},
+     "hdr.dsFromHeader(to=RPMTAG_REQUIRENAME, flags=None)\nGet dependency set from header. to must be one of the NAME tags\nbelonging to a dependency:\n'Providename', 'Requirename', 'Obsoletename', 'Conflictname',\n'Triggername', 'Recommendname', 'Suggestname', 'Supplementname',\n'Enhancename' or one of the corresponding RPMTAG_*NAME constants." },
     {"fiFromHeader",	(PyCFunction)hdr_fiFromHeader,	METH_VARARGS|METH_KEYWORDS,
-	NULL},
+     "hdr.fiFromHeader() -- Return rpm.fi object containing the file\nmeta data from the header.\n\nDEPRECATED - Use rpm.files(hdr) instead."},
     {"__reduce__",	(PyCFunction)hdr_reduce,	METH_NOARGS,
 	NULL},
 
@@ -680,7 +680,56 @@ static PySequenceMethods hdr_as_sequence = {
 };
 
 static char hdr_doc[] =
-"";
+  "A header object represents an RPM package header.\n"
+  "\n"
+  "All RPM packages have headers that provide metadata for the package.\n"
+  "Header objects can be returned by database queries or loaded from a\n"
+  "binary package on disk.\n"
+  "\n"
+  "The ts.hdrFromFdno() function returns the package header from a\n"
+  "package on disk, verifying package signatures and digests of the\n"
+  "package while reading.\n"
+  "\n"
+  "Note: The older method rpm.headerFromPackage() which has been replaced\n"
+  "by ts.hdrFromFdno() used to return a (hdr, isSource) tuple.\n"
+  "\n"
+  "If you need to distinguish source/binary headers, do:\n"
+  "\n"
+  "	import os, rpm\n"
+  "\n"
+  "	ts = rpm.TransactionSet()\n"
+  "	fdno = os.open('/tmp/foo-1.0-1.i386.rpm', os.O_RDONLY)\n"
+  "	hdr = ts.hdrFromFdno(fdno)\n"
+  "	os.close(fdno)\n"
+  "	if hdr[rpm.RPMTAG_SOURCEPACKAGE]:\n"
+  "	   print 'header is from a source package'\n"
+  "	else:\n"
+  "	   print 'header is from a binary package'\n"
+  "\n"
+  "The Python interface to the header data is quite elegant.  It\n"
+  "presents the data in a dictionary form.  We'll take the header we\n"
+  "just loaded and access the data within it:\n"
+  "\n"
+  "	print hdr[rpm.RPMTAG_NAME]\n"
+  "	print hdr[rpm.RPMTAG_VERSION]\n"
+  "	print hdr[rpm.RPMTAG_RELEASE]\n"
+  "\n"
+  "in the case of our 'foo-1.0-1.i386.rpm' package, this code would\n"
+  "output:\n"
+  "	foo\n"
+  "	1.0\n"
+  "	1\n"
+  "\n"
+  "You make also access the header data by string name:\n"
+  "\n"
+  "	print hdr['name']\n"
+  "	print hdr['version']\n"
+  "	print hdr['release']\n"
+  "\n"
+  "This method of access is a teensy bit slower because the name must be\n"
+  "translated into the tag number dynamically. You also must make sure\n"
+  "the strings in header lookups don't get translated, or the lookups\n"
+  "will fail.\n";
 
 PyTypeObject hdr_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
diff --git a/python/rpm/__init__.py b/python/rpm/__init__.py
index 196be3c..ffd17f6 100644
--- a/python/rpm/__init__.py
+++ b/python/rpm/__init__.py
@@ -2,6 +2,36 @@ r"""RPM Module
 
 This module enables you to manipulate rpms and the rpm database.
 
+The rpm base module provides the main starting point for
+accessing RPM from Python. For most usage, call
+the TransactionSet method to get a transaction set (rpmts).
+
+For example:
+	import rpm
+	ts = rpm.TransactionSet()
+
+The transaction set will open the RPM database as needed, so
+in most cases, you do not need to explicitly open the
+database. The transaction set is the workhorse of RPM.
+
+You can open another RPM database, such as one that holds
+all packages for a given Linux distribution, to provide
+packages used to solve dependencies. To do this, use
+the following code:
+
+rpm.addMacro('_dbpath', '/path/to/alternate/database')
+solvets = rpm.TransactionSet()
+solvets.openDB()
+rpm.delMacro('_dbpath')
+
+# Open default database
+ts = rpm.TransactionSet()
+
+This code gives you access to two RPM databases through
+two transaction sets (rpmts): ts is a transaction set
+associated with the default RPM database and solvets
+is a transaction set tied to an alternate database, which
+is very useful for resolving dependencies.
 """
 
 import warnings
@@ -33,6 +63,7 @@ except ImportError:
 ts = TransactionSet
 
 def headerLoad(*args, **kwds):
+    """DEPRECATED! Use rpm.hdr() instead."""
     warnings.warn("Use rpm.hdr() instead.", DeprecationWarning, stacklevel=2)
     return hdr(*args, **kwds)
 
@@ -61,6 +92,7 @@ def readHeaderListFromFile(path, retrofit = True):
     return hlist
     
 def readHeaderFromFD(file_desc):
+    """Return (header, pos_before_hdr)"""
     if not isinstance(file_desc, fd):
         file_desc = fd(file_desc)
     try:
@@ -73,6 +105,7 @@ def readHeaderFromFD(file_desc):
     return (h, offset)
 
 def signalsCaught(siglist):
+    """Returns True if any of the signals was caught."""
     caught = []
     for sig in siglist:
         if signalCaught(sig):
@@ -81,4 +114,9 @@ def signalsCaught(siglist):
     return caught
 
 def dsSingle(TagN, N, EVR = "", Flags = RPMSENSE_ANY):
+    """
+    Creates a single entry dependency set (ds)
+
+    dsSingle(RPMTAG_CONFLICTNAME, "rpm") correspons to "Conflicts: rpm"
+    """
     return ds((N, Flags, EVR), TagN)
diff --git a/python/rpmarchive-py.c b/python/rpmarchive-py.c
index d61a896..53a078a 100644
--- a/python/rpmarchive-py.c
+++ b/python/rpmarchive-py.c
@@ -178,24 +178,29 @@ static PyObject *rpmarchive_writeto(rpmarchiveObject *s,
 
 static struct PyMethodDef rpmarchive_methods[] = {
     { "tell",	(PyCFunction)rpmarchive_tell,		METH_NOARGS,
-	NULL },
+      "archive.tell() -- Return current position in archive." },
     { "close",	(PyCFunction)rpmarchive_close,		METH_NOARGS,
-	NULL },
+      "archive.close() -- Close archive and do final consistency checks."},
     { "read",	(PyCFunction)rpmarchive_read,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "archive.read(size=None) -- Read next size bytes from current file.\n\n"
+      "Returns bytes\n"},
     { "write",	(PyCFunction)rpmarchive_write,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "archive.write(buffer) -- Write buffer to current file." },
     { "readto",	(PyCFunction)rpmarchive_readto,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "archive.readto(fd, nodigest=None) -- Read content of fd\n"
+      "and write as content of the current file to archive." },
     { "writeto", (PyCFunction)rpmarchive_writeto,METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "archive.writeto(fd) -- Write content of current file in archive\n to fd." },
     { "hascontent", (PyCFunction)rpmarchive_has_content, METH_NOARGS,
-	NULL },
+      "archive.hascontent() -- Return if current file has a content.\n\n"
+      "Returns false for non regular and all but one of hardlinked files."},
     { NULL, NULL, 0, NULL }
 };
 
 static char rpmarchive_doc[] =
-"";
+"Gives access to the payload of an rpm package.\n\n"
+"Is returned by .archive() method of an rpm.files instance.\n"
+"All methods can raise an IOError exception.";
 
 static PyObject *rpmarchive_iternext(rpmarchiveObject *s)
 {
diff --git a/python/rpmds-py.c b/python/rpmds-py.c
index 19ea6f5..d515731 100644
--- a/python/rpmds-py.c
+++ b/python/rpmds-py.c
@@ -190,39 +190,41 @@ static struct PyMethodDef rpmds_methods[] = {
  {"Count",	(PyCFunction)rpmds_Count,	METH_NOARGS,
 	"Deprecated, use len(ds) instead.\n" },
  {"Ix",		(PyCFunction)rpmds_Ix,		METH_NOARGS,
-	"ds.Ix -> Ix		- Return current element index.\n" },
+	"ds.Ix -> Ix -- Return current element index.\n" },
  {"DNEVR",	(PyCFunction)rpmds_DNEVR,	METH_NOARGS,
-	"ds.DNEVR -> DNEVR	- Return current DNEVR.\n" },
+	"ds.DNEVR -> DNEVR -- Return current DNEVR.\n" },
  {"N",		(PyCFunction)rpmds_N,		METH_NOARGS,
-	"ds.N -> N		- Return current N.\n" },
+	"ds.N -> N -- Return current N.\n" },
  {"EVR",	(PyCFunction)rpmds_EVR,		METH_NOARGS,
-	"ds.EVR -> EVR		- Return current EVR.\n" },
+	"ds.EVR -> EVR -- Return current EVR.\n" },
  {"Flags",	(PyCFunction)rpmds_Flags,	METH_NOARGS,
-	"ds.Flags -> Flags	- Return current Flags.\n" },
+	"ds.Flags -> Flags -- Return current Flags.\n" },
  {"TagN",	(PyCFunction)rpmds_TagN,	METH_NOARGS,
-	"ds.TagN -> TagN	- Return current TagN.\n" },
+  "ds.TagN -> TagN -- Return TagN (RPMTAG_*NAME)\n\n"
+  "the type of all dependencies in this set.\n" },
  {"Color",	(PyCFunction)rpmds_Color,	METH_NOARGS,
-	"ds.Color -> Color	- Return current Color.\n" },
+	"ds.Color -> Color -- Return current Color.\n" },
  {"SetNoPromote",(PyCFunction)rpmds_SetNoPromote, METH_VARARGS|METH_KEYWORDS,
-	NULL},
+  "ds.SetNoPromote(noPromote) -- Set noPromote for this instance.\n\n"
+  "If True non existing epochs are no longer equal to an epoch of 0."},
  {"Notify",	(PyCFunction)rpmds_Notify,	METH_VARARGS|METH_KEYWORDS,
-	NULL},
+  "ds.Notify(location, returnCode) -- Print debug info message\n\n if debugging is enabled."},
  {"Sort",	(PyCFunction)rpmds_Sort,	METH_NOARGS,
 	NULL},
  {"Find",	(PyCFunction)rpmds_Find,	METH_O,
-	NULL},
+  "ds.find(other_ds) -- Return index of other_ds in ds"},
  {"Merge",	(PyCFunction)rpmds_Merge,	METH_O,
 	NULL},
  {"Search",     (PyCFunction)rpmds_Search,      METH_O,
 "ds.Search(element) -> matching ds index (-1 on failure)\n\
-- Check that element dependency range overlaps some member of ds.\n\
-The current index in ds is positioned at overlapping member upon success.\n" },
+Check that element dependency range overlaps some member of ds.\n\
+The current index in ds is positioned at overlapping member." },
  {"Rpmlib",     (PyCFunction)rpmds_Rpmlib,      METH_VARARGS|METH_KEYWORDS|METH_STATIC,
-	"ds.Rpmlib -> nds       - Return internal rpmlib dependency set.\n"},
+	"ds.Rpmlib -> nds -- Return internal rpmlib dependency set.\n"},
  {"Compare",	(PyCFunction)rpmds_Compare,	METH_O,
-	NULL},
+  "ds.compare(other) -- Compare current entries of self and other.\n\nReturns True if the entries match each other, False otherwise"},
  {"Instance",	(PyCFunction)rpmds_Instance,	METH_NOARGS,
-	NULL},
+  "ds.Instance() -- Return rpmdb key of corresponding package or 0."},
  {NULL,		NULL}		/* sentinel */
 };
 
@@ -346,7 +348,11 @@ static PyObject * rpmds_new(PyTypeObject * subtype, PyObject *args, PyObject *kw
 }
 
 static char rpmds_doc[] =
-"";
+    "rpm.ds (dependendcy set) gives a more convenient access to dependencies\n\n"
+    "It can hold multiple entries of Name Flags and EVR.\n"
+    "It typically represents all dependencies of one kind of a package\n"
+    "e.g. all Requires or all Conflicts.\n"
+    ;
 
 PyTypeObject rpmds_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
diff --git a/python/rpmfi-py.c b/python/rpmfi-py.c
index be80f4d..cf1b016 100644
--- a/python/rpmfi-py.c
+++ b/python/rpmfi-py.c
@@ -238,51 +238,51 @@ rpmfi_iternext(rpmfiObject * s)
 
 static struct PyMethodDef rpmfi_methods[] = {
  {"FC",		(PyCFunction)rpmfi_FC,		METH_NOARGS,
-	NULL},
+  "fi.FC() -- Return number of files entries."},
  {"FX",		(PyCFunction)rpmfi_FX,		METH_NOARGS,
-	NULL},
+  "fi.FX() -- Return current position of the iterator."},
  {"DC",		(PyCFunction)rpmfi_DC,		METH_NOARGS,
-	NULL},
+  "fi.DC() --Return number of directory entries."},
  {"DX",		(PyCFunction)rpmfi_DX,		METH_NOARGS,
-	NULL},
+  "fi.DX() -- Return number of directory entry matching current file."},
  {"BN",		(PyCFunction)rpmfi_BN,		METH_NOARGS,
-	NULL},
+  "fi.BN() -- Return base name of current file."},
  {"DN",		(PyCFunction)rpmfi_DN,		METH_NOARGS,
-	NULL},
+  "fi.DN() -- Return directory name of the current file."},
  {"FN",		(PyCFunction)rpmfi_FN,		METH_NOARGS,
-	NULL},
+  "fi.FN() -- Return the name/path of the current file."},
  {"FindFN",	(PyCFunction)rpmfi_FindFN,	METH_VARARGS|METH_KEYWORDS,
-	NULL},
+  "fi.FindFN(pathname) -- Return entry number of given pathname.\n\nReturn -1 if file is not found.\nLeading '.' in the given name is stripped before the search."},
  {"FFlags",	(PyCFunction)rpmfi_FFlags,	METH_NOARGS,
-	NULL},
+  "fi.FFlags() -- Return the flags of the current file."},
  {"VFlags",	(PyCFunction)rpmfi_VFlags,	METH_NOARGS,
-	NULL},
+  "fi.VFlags() -- Return the verify flags of the current file.\n\nSee RPMVERIFY_* (in rpmvf.h)"},
  {"FMode",	(PyCFunction)rpmfi_FMode,	METH_NOARGS,
-	NULL},
+  "fi.FMode() -- Return the mode flags of the current file."},
  {"FState",	(PyCFunction)rpmfi_FState,	METH_NOARGS,
-	NULL},
+  "fi.FState() -- Return the file state of the current file."},
  {"MD5",	(PyCFunction)rpmfi_Digest,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the checksum of the current file.\n\nDEPRECATED! Use fi.Digest instead!"},
  {"Digest",	(PyCFunction)rpmfi_Digest,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the checksum of the current file."},
  {"FLink",	(PyCFunction)rpmfi_FLink,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the link target of the current file.\n\nFor soft links only."},
  {"FSize",	(PyCFunction)rpmfi_FSize,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the size of the current file."},
  {"FRdev",	(PyCFunction)rpmfi_FRdev,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the device number of the current file.\n\nFor device files only."},
  {"FMtime",	(PyCFunction)rpmfi_FMtime,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the modification time of the current file."},
  {"FUser",	(PyCFunction)rpmfi_FUser,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the user name owning the current file."},
  {"FGroup",	(PyCFunction)rpmfi_FGroup,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the group name of the current file."},
  {"FColor",	(PyCFunction)rpmfi_FColor,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the color of the current file.\n\n2 for 64 bit binaries\n1 for 32 bit binaries\n0 for everything else"},
  {"FClass",	(PyCFunction)rpmfi_FClass,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the classification of the current file."},
  {"FLinks",	(PyCFunction)rpmfi_FLinks,	METH_NOARGS,
-	NULL},
+  "fi.() -- Return the number of hardlinks pointing to of the\ncurrent file."},
  {NULL,		NULL}		/* sentinel */
 };
 
@@ -354,7 +354,11 @@ static PyObject * rpmfi_new(PyTypeObject * subtype, PyObject *args, PyObject *kw
 }
 
 static char rpmfi_doc[] =
-"";
+"File iterator\n\n"
+"DEPRECATED! This old API mixes storing and iterating over the meta data\n"
+"of the files of a package. Use rpm.files and rpm.file data types as a\n"
+"much cleaner API.\n\n"
+"Iteration returns a tuple of\n(FN, FSize, FMode, FMtime, FFlags, FRdev, FInode, FNlink, FState,\n VFlags, FUser, FGroup, Digest)";
 
 PyTypeObject rpmfi_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
diff --git a/python/rpmfiles-py.c b/python/rpmfiles-py.c
index 782d201..beb1da9 100644
--- a/python/rpmfiles-py.c
+++ b/python/rpmfiles-py.c
@@ -25,7 +25,8 @@ static void rpmfile_dealloc(rpmfileObject * s)
 }
 
 static char rpmfile_doc[] =
-"";
+    "Gives access to the meta data of a single file.\n\n"
+    "Instances of this class are only available through an rpm.files object.";
 
 static PyObject *rpmfile_fx(rpmfileObject *s)
 {
@@ -216,32 +217,56 @@ static PyObject *rpmfile_matches(rpmfileObject *s, PyObject *o)
 }
 
 static PyGetSetDef rpmfile_getseters[] = {
-    { "fx",		(getter) rpmfile_fx,		NULL, NULL },
-    { "dx",		(getter) rpmfile_dx,		NULL, NULL },
-    { "name",		(getter) rpmfile_name,		NULL, NULL },
+    { "fx",		(getter) rpmfile_fx,		NULL,
+      "index in header and rpm.files object" },
+    { "dx",		(getter) rpmfile_dx,		NULL,
+      "index of dirname entry" },
+    { "name",		(getter) rpmfile_name,		NULL,
+      "file name (path)" },
     { "basename",	(getter) rpmfile_basename,	NULL, NULL },
     { "dirname",	(getter) rpmfile_dirname,	NULL, NULL },
-    { "orig_name",	(getter) rpmfile_orig_name,	NULL, NULL },
-    { "orig_basename",	(getter) rpmfile_orig_basename,	NULL, NULL },
-    { "orig_dirname",	(getter) rpmfile_orig_dirname,	NULL, NULL },
-    { "mode",		(getter) rpmfile_mode,		NULL, NULL },
-    { "mtime",		(getter) rpmfile_mtime,		NULL, NULL },
-    { "size",		(getter) rpmfile_size,		NULL, NULL },
-    { "rdev",		(getter) rpmfile_rdev,		NULL, NULL },
-    { "inode",		(getter) rpmfile_inode,		NULL, NULL },
-    { "fflags",		(getter) rpmfile_fflags,	NULL, NULL },
-    { "vflags",		(getter) rpmfile_vflags,	NULL, NULL },
-    { "linkto",		(getter) rpmfile_linkto,	NULL, NULL },
-    { "color",		(getter) rpmfile_color,		NULL, NULL },
-    { "nlink",		(getter) rpmfile_nlink,		NULL, NULL },
-    { "links",		(getter) rpmfile_links,		NULL, NULL },
-    { "user",		(getter) rpmfile_user,		NULL, NULL },
-    { "group",		(getter) rpmfile_group,		NULL, NULL },
-    { "digest",		(getter) rpmfile_digest,	NULL, NULL },
-    { "class",		(getter) rpmfile_class,		NULL, NULL },
-    { "state",		(getter) rpmfile_state,		NULL, NULL },
-    { "langs",		(getter) rpmfile_langs,		NULL, NULL },
-    { "caps",		(getter) rpmfile_caps,		NULL, NULL },
+    { "orig_name",	(getter) rpmfile_orig_name,	NULL,
+      "original file name (may differ due to relocation)" },
+    { "orig_basename",	(getter) rpmfile_orig_basename,	NULL,
+      "original base name (may differ due to relocation)" },
+    { "orig_dirname",	(getter) rpmfile_orig_dirname,	NULL,
+      "original dir name (may differ due to relocation)" },
+    { "mode",		(getter) rpmfile_mode,		NULL,
+      "mode flags / unix permissions" },
+    { "mtime",		(getter) rpmfile_mtime,		NULL,
+      "modification time (in unix time)" },
+    { "size",		(getter) rpmfile_size,		NULL,
+      "file size" },
+    { "rdev",		(getter) rpmfile_rdev,		NULL,
+      "device number - for device files only" },
+    { "inode",		(getter) rpmfile_inode,		NULL,
+      "inode number - contains fake, data used to identify hard liked files" },
+    { "fflags",		(getter) rpmfile_fflags,	NULL,
+      "file flags - see RPMFILE_* constants" },
+    { "vflags",		(getter) rpmfile_vflags,	NULL,
+      "verification flags - see RPMVERIFY_* (in rpmvf.h)" },
+    { "linkto",		(getter) rpmfile_linkto,	NULL,
+      "link target - symlinks only" },
+    { "color",		(getter) rpmfile_color,		NULL,
+      "file color - 2 for 64 bit binaries, 1 for 32 bit binaries, 0 else" },
+    { "nlink",		(getter) rpmfile_nlink,		NULL,
+      "number of hardlinks pointing to the same content as this file" },
+    { "links",		(getter) rpmfile_links,		NULL,
+      "list of file indexes that are hardlinked with this file" },
+    { "user",		(getter) rpmfile_user,		NULL,
+      "user name owning this file" },
+    { "group",		(getter) rpmfile_group,		NULL,
+      "group name owning this file" },
+    { "digest",		(getter) rpmfile_digest,	NULL,
+      "check sum of file content" },
+    { "class",		(getter) rpmfile_class,		NULL,
+      "classfication of file content based on libmagic/file(1)" },
+    { "state",		(getter) rpmfile_state,		NULL,
+      "file state  - see RPMFILE_STATE_* constants" },
+    { "langs",		(getter) rpmfile_langs,		NULL,
+      "language the file provides (typically for doc files)" },
+    { "caps",		(getter) rpmfile_caps,		NULL,
+      "file capabilities" },
     { NULL, NULL, NULL, NULL }
 };
 
@@ -484,15 +509,26 @@ static PyMappingMethods rpmfiles_as_mapping = {
 
 static struct PyMethodDef rpmfiles_methods[] = {
     { "archive", (PyCFunction) rpmfiles_archive, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "files.archive(fd, write=False) -- Return a rpm.archive object\n\n"
+      "Args:\n"
+      "  fd : File to read from or write to.\n"
+      "  write : True to get an archive writer, False for an archive reader"},
     { "find",	(PyCFunction) rpmfiles_find,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "files.find(filename, orig=False) -- Return index of given file name.\n\n"
+      "  Return -1 if file is not found.\n"
+      "  Leading \".\" in filename is ignored."},
     { NULL, NULL, 0, NULL }
 };
 
 static char rpmfiles_doc[] =
-"";
-
+    "rpm.files(hdr, tag=RPMTAG_BASENAMES, flags=None, pool=None)\n\n"
+    "Stores the meta data of a package's files.\n\n"
+    "Args:\n"
+    "\thdr: The header object to get the data from.\n"
+    "\tflags : Controls which data to store and whether to create\n\t\tcopies or use the data from the header.\n\t\tBy default all data is copied.\n\t\tSee RPMFI_* constants in rpmfiles.h.\n"
+    "\tpool : rpm.strpool object to store the strings in.\n\t\tLeave empty to use global pool.\n"
+    "\ttag : Obsolete. Leave alone!\n\n"
+    "rpm.files is basically a sequence of rpm.file objects.\nNote that this is a read only data structure. To write file data you\nhave to write it directly into aheader object.";
 
 PyTypeObject rpmfiles_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
diff --git a/python/rpmmi-py.c b/python/rpmmi-py.c
index e581b27..0e27575 100644
--- a/python/rpmmi-py.c
+++ b/python/rpmmi-py.c
@@ -36,20 +36,20 @@
  * \code
  *	import rpm
  *	ts = rpm.TransactionSet()
- *	mi = ts.dbMatch('name', "kernel")
+ *	mi = ts.dbMatch('name', 'kernel')
  *	for h in mi:
- *	    print "%s-%s-%s" % (h['name'], h['version'], h['release'])
+ *	    print '%s-%s-%s' % (h['name'], h['version'], h['release'])
  * \endcode
  *
  * Finally, here's an example that retrieves all packages whose name
- * matches the glob expression "XFree*":
+ * matches the glob expression 'XFree*':
  * \code
  *	import rpm
  *	ts = rpm.TransactionSet()
  *	mi = ts.dbMatch()
- *	mi.pattern('name', rpm.RPMMIRE_GLOB, "XFree*")
+ *	mi.pattern('name', rpm.RPMMIRE_GLOB, 'XFree*')
  *	for h in mi:
- *	    print "%s-%s-%s" % (h['name'], h['version'], h['release'])
+ *	    print '%s-%s-%s' % (h['name'], h['version'], h['release'])
  * \endcode
  *
  */
@@ -114,7 +114,7 @@ rpmmi_Pattern(rpmmiObject * s, PyObject * args, PyObject * kwds)
 
 static struct PyMethodDef rpmmi_methods[] = {
     {"instance",    (PyCFunction) rpmmi_Instance,	METH_NOARGS,
-	NULL },
+     "mi.instance() -- Return the number (db key) of the current header."},
     {"count",       (PyCFunction) rpmmi_Count,		METH_NOARGS,
 "Deprecated, use len(mi) instead.\n" },
     {"pattern",	    (PyCFunction) rpmmi_Pattern,	METH_VARARGS|METH_KEYWORDS,
@@ -162,7 +162,40 @@ static PyNumberMethods rpmmi_as_number = {
 };
 
 static char rpmmi_doc[] =
-"";
+  "rpm.mi match iterator object represents the result of a\n"
+  "	database query.\n"
+  "\n"
+  "Instances of the rpm.mi object provide access to headers that match\n"
+  "certain criteria. Typically, a primary index is accessed to find\n"
+  "a set of headers that contain a key, and each header is returned\n"
+  "serially.\n"
+  "\n"
+  "To obtain a rpm.mi object to query the database used by a transaction,\n"
+  "the ts.match(tag,key,len) method is used.\n"
+  "\n"
+  "Here's an example that prints the name of all installed packages:\n"
+  "	import rpm\n"
+  "	ts = rpm.TransactionSet()\n"
+  "	for h in ts.dbMatch():\n"
+  "	    print h['name']\n"
+  "\n"
+  "Here's a more typical example that uses the Name index to retrieve\n"
+  "all installed kernel(s):\n"
+  "	import rpm\n"
+  "	ts = rpm.TransactionSet()\n"
+  "	mi = ts.dbMatch('name', 'kernel')\n"
+  "	for h in mi:\n"
+  "	    print '%s-%s-%s' % (h['name'], h['version'], h['release'])\n"
+  "\n"
+  "Finally, here's an example that retrieves all packages whose name\n"
+  "matches the glob expression 'XFree*':\n"
+  "	import rpm\n"
+  "	ts = rpm.TransactionSet()\n"
+  "	mi = ts.dbMatch()\n"
+  "	mi.pattern('name', rpm.RPMMIRE_GLOB, 'XFree*')\n"
+  "	for h in mi:\n"
+  "	    print '%s-%s-%s' % (h['name'], h['version'], h['release'])\n"
+;
 
 PyTypeObject rpmmi_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
diff --git a/python/rpmmodule.c b/python/rpmmodule.c
index 4e6fe27..266650b 100644
--- a/python/rpmmodule.c
+++ b/python/rpmmodule.c
@@ -136,40 +136,49 @@ static PyObject * reloadConfig(PyObject * self, PyObject * args, PyObject *kwds)
 
 static PyMethodDef rpmModuleMethods[] = {
     { "addMacro", (PyCFunction) rpmmacro_AddMacro, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "addMacro(macro, value)\n"
+    },
     { "delMacro", (PyCFunction) rpmmacro_DelMacro, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "delMacro(macro)\n"
+    },
     { "expandMacro", (PyCFunction) rpmmacro_ExpandMacro, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "expandMacro(string, numeric=False) -- expands a string containing macros\n\n"
+      "Returns an int if numeric is True. 'Y' or 'y' returns 1,\n'N' or 'n' returns 0\nAn undefined macro returns 0."},
 
     { "archscore", (PyCFunction) archScore, METH_O,
-	NULL },
+      "archscore(archname) -- How well does an architecture fit on this machine\n\n"
+      "0 for non matching arch names\n1 for best arch\nhigher numbers for less fitting arches\n(e.g. 2 for \"i586\" on an i686 machine)" },
 
     { "signalCaught", (PyCFunction) signalCaught, METH_O, 
-	NULL },
+	"signalCaught(signo) -- Returns True if signal was caught." },
     { "checkSignals", (PyCFunction) checkSignals, METH_NOARGS,
-        NULL },
+      "checkSignals() -- Check for and exit on termination signals."},
 
     { "mergeHeaderListFromFD", (PyCFunction) rpmMergeHeadersFromFD, METH_VARARGS|METH_KEYWORDS,
 	NULL },
 
     { "log",		(PyCFunction) doLog, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+	"log(level, msg) -- Write msg to log if level is selected to be logged.\n\n"
+    "level must be one of the RPMLOG_* constants."},
     { "setLogFile", (PyCFunction) setLogFile, METH_O,
-	NULL },
+	"setLogFile(file) -- set file to write log messages to or None." },
 
     { "versionCompare", (PyCFunction) versionCompare, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "versionCompare(version0, version1) -- compares two version strings\n\n"
+      "Returns 1 if version0 > version1\n"
+      "Returns 0 if version0 == version1\n"
+      "Returns -1 if version0 < version1\n"},
     { "labelCompare", (PyCFunction) labelCompare, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "labelCompare(version0, version1) -- as versionCompare()\n\n"
+      "but arguments are tuples of of strings for (epoch, version, release)"},
     { "setVerbosity", (PyCFunction) setVerbosity, METH_O,
-	NULL },
+      "setVerbosity(level) -- Set log level. See RPMLOG_* constants." },
     { "setEpochPromote", (PyCFunction) setEpochPromote, METH_O,
-	NULL },
+	"setEpochPromote(bool) -- Set if no epoch shall be treated as epoch 0" },
     { "setStats", (PyCFunction) setStats, METH_O,
-	NULL },
+      "setStats(bool) -- Set if timing stats are printed after a transaction."},
     { "reloadConfig", (PyCFunction) reloadConfig, METH_VARARGS|METH_KEYWORDS,
-	NULL },
+      "readloadConfig(path=None) -- Read config file.\n\nSet all macros and settings accordingly."},
 
     { NULL }
 } ;
@@ -182,8 +191,7 @@ static void rpm_exithook(void)
    rpmdbCheckTerminate(1);
 }
 
-static char rpm__doc__[] =
-"";
+static char rpm__doc__[] = "";
 
 /*
  * Add rpm tag dictionaries to the module
diff --git a/python/rpmte-py.c b/python/rpmte-py.c
index d67f0a5..6936e75 100644
--- a/python/rpmte-py.c
+++ b/python/rpmte-py.c
@@ -204,58 +204,49 @@ rpmte_Files(rpmteObject * s, PyObject * args, PyObject * kwds)
 }
 static struct PyMethodDef rpmte_methods[] = {
     {"Type",	(PyCFunction)rpmte_TEType,	METH_NOARGS,
-"te.Type() -> Type\n\
-- Return element type (rpm.TR_ADDED | rpm.TR_REMOVED).\n" },
+     "te.Type() -- Return element type (rpm.TR_ADDED | rpm.TR_REMOVED).\n" },
     {"N",	(PyCFunction)rpmte_N,		METH_NOARGS,
-"te.N() -> N\n\
-- Return element name.\n" },
+     "te.N() -- Return element name.\n" },
     {"E",	(PyCFunction)rpmte_E,		METH_NOARGS,
-"te.E() -> E\n\
-- Return element epoch.\n" },
+     "te.E() -- Return element epoch.\n" },
     {"V",	(PyCFunction)rpmte_V,		METH_NOARGS,
-"te.V() -> V\n\
-- Return element version.\n" },
+     "te.V() -- Return element version.\n" },
     {"R",	(PyCFunction)rpmte_R,		METH_NOARGS,
-"te.R() -> R\n\
-- Return element release.\n" },
+     "te.R() -- Return element release.\n" },
     {"A",	(PyCFunction)rpmte_A,		METH_NOARGS,
-"te.A() -> A\n\
-- Return element arch.\n" },
+     "te.A() -- Return element arch.\n" },
     {"O",	(PyCFunction)rpmte_O,		METH_NOARGS,
-"te.O() -> O\n\
-- Return element os.\n" },
+     "te.O() -- Return element os.\n" },
     {"NEVR",	(PyCFunction)rpmte_NEVR,	METH_NOARGS,
-"te.NEVR() -> NEVR\n\
-- Return element name-[epoch:]version-release.\n" },
+     "te.NEVR() -- Return element name-[epoch:]version-release.\n" },
     {"NEVRA",	(PyCFunction)rpmte_NEVRA,	METH_NOARGS,
-"te.NEVRA() -> NEVRA\n\
-- Return element name-[epoch:]version-release.arch\n" },
+     "te.NEVRA() -- Return element name-[epoch:]version-release.arch\n" },
     {"Color",(PyCFunction)rpmte_Color,		METH_NOARGS,
-	NULL},
+     "te.Color() -- Return package color bits."},
     {"PkgFileSize",(PyCFunction)rpmte_PkgFileSize,	METH_NOARGS,
-	NULL},
+     "te.PkgFileSize() -- Return no. of bytes in package file (approx)."},
     {"Parent",	(PyCFunction)rpmte_Parent,	METH_NOARGS,
-	NULL},
+     "te.Parent() -- Return the parent element index."},
     {"Problems",(PyCFunction)rpmte_Problems,	METH_NOARGS,
-	NULL},
+     "te.Problems() -- Return problems associated with this element."},
 /*    {"DependsOnKey",(PyCFunction)rpmte_DependsOnKey,	METH_NOARGS,
       NULL}, */
     {"DBOffset",(PyCFunction)rpmte_DBOffset,	METH_NOARGS,
-	NULL},
+     "te.DBOffset() -- Return the Package's database instance number.\n\nTR_REMOVED only"},
     {"Failed",	(PyCFunction)rpmte_Failed,	METH_NOARGS,
-	NULL},
+     "te.Failed() -- Return if there are any related errors."},
     {"Key",	(PyCFunction)rpmte_Key,		METH_NOARGS,
-	NULL},
+     "te.Key() -- Return the associated opaque key aka user data\n\
+	as passed e.g. as data arg ts.addInstall()"},
     {"DS",	(PyCFunction)rpmte_DS,		METH_VARARGS|METH_KEYWORDS,
-"te.DS(TagN) -> DS\n\
-- Return the TagN dependency set (or None). TagN is one of\n\
-	'Providename', 'Requirename', 'Obsoletename', 'Conflictname'\n" },
+"te.DS(TagN) -- Return the TagN dependency set (or None).\n\
+	TagN is one of 'Providename', 'Requirename', 'Obsoletename',\n\
+	'Conflictname', 'Triggername', 'Recommendname', 'Suggestname',\n\
+	'Supplementname', 'Enhancename'" },
     {"FI",	(PyCFunction)rpmte_FI,		METH_VARARGS|METH_KEYWORDS,
-"te.FI(TagN) -> FI\n\
-- Return file info iterator of element. Deprecated, use .Files() instead.\n" },
+"te.FI(TagN) -- Return file info iterator of element.\n\n DEPRECATED! Use .Files() instead.\n" },
     {"Files",	(PyCFunction)rpmte_Files,	METH_NOARGS,
-"te.Files() -> files\n\
-- Return file info set of element.\n" },
+"te.Files() -- Return file info set of element.\n" },
     {NULL,		NULL}		/* sentinel */
 };
 
diff --git a/python/rpmts-py.c b/python/rpmts-py.c
index 5d90fed..d5029b5 100644
--- a/python/rpmts-py.c
+++ b/python/rpmts-py.c
@@ -691,15 +691,55 @@ exit:
 
 static struct PyMethodDef rpmts_methods[] = {
  {"addInstall",	(PyCFunction) rpmts_AddInstall,	METH_VARARGS,
-	NULL },
+  "ts.addInstall(hdr, data, mode) --  Add transaction element(s)\n"
+  "representing an installation or update of a package.\n\n"
+  "Args:\n"
+  "  hdr : the header to be added\n"
+  "  data : user data that will be passed to the transaction callback\n\t\tduring transaction execution\n"
+  "  mode : optional argument that specifies if this package should be\n\t\tinstalled ('i'), upgraded ('u')"},
  {"addReinstall",	(PyCFunction) rpmts_AddReinstall,	METH_VARARGS,
-	NULL },
+  "ts.addReinstall(hdr, data) -- Adds transaction elements\nrepresenting a reinstall of an already installed package.\n\nSee addInstall for details."},
  {"addErase",	(PyCFunction) rpmts_AddErase,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+  "addErase(name) -- Add a transaction element representing an erase\nof an installed package.\n\n"
+  "  name: the package name to be erased"},
  {"check",	(PyCFunction) rpmts_Check,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+  "ts.check( )-- Perform a dependency check on the transaction set.\n"
+  "		After headers have been added to a transaction set,\n"
+  "		a dependencycheck can be performed to make sure that\n"
+  "		all package dependencies are satisfied.\n"
+  "Return	None If there are no unresolved dependencies\n"
+  "		Otherwise a list of complex tuples is returned,\n"
+  "		one tuple per unresolved dependency, with\n"
+  "The format of the dependency tuple is:\n"
+  "    ((packageName, packageVersion, packageRelease),\n"
+  "     (reqName, reqVersion),\n"
+  "     needsFlags,\n"
+  "     suggestedPackage,\n"
+  "     sense)\n"
+  "  packageName, packageVersion, packageRelease are the name,\n"
+  "    version, and release of the package that has the unresolved\n"
+  "    dependency or conflict.\n"
+  "  The reqName and reqVersion are the name and version of the\n"
+  "    requirement or conflict.\n"
+  "  The needsFlags is a bitfield that describes the versioned\n"
+  "    nature of a requirement or conflict.  The constants\n"
+  "    rpm.RPMSENSE_LESS, rpm.RPMSENSE_GREATER, and\n"
+  "    rpm.RPMSENSE_EQUAL can be logical ANDed with the needsFlags\n"
+  "    to get versioned dependency information.\n"
+  "  suggestedPackage is a tuple if the dependency check was aware\n"
+  "    of a package that solves this dependency problem when the\n"
+  "    dependency check was run.  Packages that are added to the\n"
+  "    transaction set as \"available\" are examined during the\n"
+  "    dependency check as possible dependency solvers. The tuple\n"
+  "    contains two values, (header, suggestedName).  These are set to\n"
+  "    the header of the suggested package and its name, respectively.\n"
+  "    If there is no known package to solve the dependency problem,\n"
+  "    suggestedPackage is None.\n"
+  "  The constants rpm.RPMDEP_SENSE_CONFLICTS and\n"
+  "    rpm.RPMDEP_SENSE_REQUIRES are set to show a dependency as a\n"
+  "    requirement or a conflict.\n"},
  {"order",	(PyCFunction) rpmts_Order,	METH_NOARGS,
-	NULL },
+  "ts.order() Do a topological sort of added element relations." },
  {"problems",	(PyCFunction) rpmts_Problems,	METH_NOARGS,
 "ts.problems() -> ps\n\
 - Return current problem set.\n" },
@@ -708,18 +748,18 @@ static struct PyMethodDef rpmts_methods[] = {
 - Run a transaction set, returning list of problems found.\n\
   Note: The callback may not be None.\n" },
  {"clean",	(PyCFunction) rpmts_Clean,	METH_NOARGS,
-	NULL },
+  "ts.clean()-- Free memory needed only for dependency checks\nand ordering. Should not be needed in normal operation." },
  {"clear",	(PyCFunction) rpmts_Clear,	METH_NOARGS,
 "ts.clear() -> None\n\
 Remove all elements from the transaction set\n" },
  {"openDB",	(PyCFunction) rpmts_OpenDB,	METH_NOARGS,
-"ts.openDB() -> None\n\
-- Open the default transaction rpmdb.\n\
-  Note: The transaction rpmdb is lazily opened, so ts.openDB() is seldom needed.\n" },
+"ts.openDB() -> None -- Open the default transaction rpmdb.\n\n\
+  Note: The transaction rpmdb is lazily opened,\n  so ts.openDB() is seldom needed.\n" },
  {"closeDB",	(PyCFunction) rpmts_CloseDB,	METH_NOARGS,
 "ts.closeDB() -> None\n\
 - Close the default transaction rpmdb.\n\
-  Note: ts.closeDB() disables lazy opens, and should hardly ever be used.\n" },
+  Note: ts.closeDB() disables lazy opens,\n\
+  and should hardly ever be used.\n" },
  {"initDB",	(PyCFunction) rpmts_InitDB,	METH_NOARGS,
 "ts.initDB() -> None\n\
 - Initialize the default transaction rpmdb.\n\
@@ -734,15 +774,21 @@ Remove all elements from the transaction set\n" },
 "ts.hdrFromFdno(fdno) -> hdr\n\
 - Read a package header from a file descriptor.\n" },
  {"hdrCheck",	(PyCFunction) rpmts_HdrCheck,	METH_O,
-	NULL },
+  "ts.hdrCheck(hdrblob) -- Check header consistency,\nperforming headerGetEntry() the hard way.\n\n"
+  "Sanity checks on the header are performed while looking for a\n"
+  "header-only digest or signature to verify the blob. If found,\n"
+  "the digest or signature is verified.\n\n"
+  "\thdrblob : unloaded header blob\n"
+  "Return tuple (int status, message string)"},
  {"pgpPrtPkts",	(PyCFunction) rpmts_PgpPrtPkts,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+  "pgpPrtPkts(octets) -- Print/parse a OpenPGP packet(s).\n\nReturn 0 on success." },
  {"pgpImportPubkey",	(PyCFunction) rpmts_PgpImportPubkey,	METH_VARARGS|METH_KEYWORDS,
-	NULL },
+  "pgpImportPubkey(pubkey) -- Import public key packet." },
  {"getKeyring",	(PyCFunction) rpmts_getKeyring,	METH_VARARGS|METH_KEYWORDS, 
-	NULL },
+  "ts.getKeyring(autoload=False) -- Return key ring object." },
  {"setKeyring",	(PyCFunction) rpmts_setKeyring,	METH_O, 
-	NULL },
+  "ts.setKeyring(keyring) -- Set key ring used for checking signatures\n\n"
+  "Pass None for an empty key ring." },
  {"dbMatch",	(PyCFunction) rpmts_Match,	METH_VARARGS|METH_KEYWORDS,
 "ts.dbMatch([TagN, [key]]) -> mi\n\
 - Create a match iterator for the default transaction rpmdb.\n" },
@@ -880,13 +926,38 @@ static PyObject *rpmts_get_vsflags(rpmtsObject *s, void *closure)
 }
 
 static char rpmts_doc[] =
-"";
+  "A python rpm.ts object represents an RPM transaction set.\n"
+  "\n"
+  "The transaction set is the workhorse of RPM. It performs the\n"
+  "installation and upgrade of packages. The rpm.ts object is\n"
+  "instantiated by the TransactionSet function in the rpm module.\n"
+  "\n"
+  "The TransactionSet function takes two optional arguments. The first\n"
+  "argument is the root path. The second is the verify signature disable\n"
+  "flags, a set of the following bits:\n"
+  "\n"
+  "-    rpm.RPMVSF_NOHDRCHK	if set, don't check rpmdb headers\n"
+  "-    rpm.RPMVSF_NEEDPAYLOAD	if not set, check header+payload\n"
+  "				(if possible)\n"
+  "-    rpm.RPMVSF_NOSHA1HEADER	if set, don't check header SHA1 digest\n"
+  "-    rpm.RPMVSF_NODSAHEADER	if set, don't check header DSA signature\n"
+  "-    rpm.RPMVSF_NOMD5	if set, don't check header+payload MD5 digest\n"
+  "-    rpm.RPMVSF_NODSA	if set, don't check header+payload DSA signature\n"
+  "-    rpm.RPMVSF_NORSA	if set, don't check header+payload RSA signature\n"
+  "\n"
+  "For convenience, there are the following masks:\n"
+  "-    rpm._RPMVSF_NODIGESTS	if set, don't check digest(s).\n"
+  "-    rpm._RPMVSF_NOSIGNATURES	if set, don't check signature(s).\n\n"
+  "The transaction set offers an read only iterable interface for the\ntransaction elements added by the .addInstall(), .addErase() and\n.addReinstall() methods.";
 
 static PyGetSetDef rpmts_getseters[] = {
 	/* only provide a setter until we have rpmfd wrappings */
-	{"scriptFd",	NULL,	(setter)rpmts_set_scriptFd, NULL },
-	{"tid",		(getter)rpmts_get_tid, NULL, NULL },
-	{"rootDir",	(getter)rpmts_get_rootDir, NULL, NULL },
+	{"scriptFd",	NULL,	(setter)rpmts_set_scriptFd,
+	 "write only, file descriptor the output of script gets written to." },
+	{"tid",		(getter)rpmts_get_tid, NULL,
+	 "read only, current transaction id, i.e. transaction time stamp."},
+	{"rootDir",	(getter)rpmts_get_rootDir, NULL,
+	 "read only, directory rpm treats as root of the file system." },
 	{"_color",	(getter)rpmts_get_color, (setter)rpmts_set_color, NULL},
 	{"_prefcolor",	(getter)rpmts_get_prefcolor, (setter)rpmts_set_prefcolor, NULL},
 	{"_flags",	(getter)rpmts_get_flags, (setter)rpmts_set_flags, NULL},
