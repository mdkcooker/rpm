diff -p -up rpm-4.6.1/tools/debugedit.c.0164 rpm-4.6.1/tools/debugedit.c
--- rpm-4.6.1/tools/debugedit.c.0164	2009-05-08 14:15:18.000000000 +0200
+++ rpm-4.6.1/tools/debugedit.c	2010-09-29 08:40:19.145281925 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002, 2003, 2005, 2007 Red Hat, Inc.
+/* Copyright (C) 2001, 2002, 2003, 2005, 2007, 2009, 2010 Red Hat, Inc.
    Written by Alexander Larsson <alexl@redhat.com>, 2002
    Based on code by Jakub Jelinek <jakub@redhat.com>, 2001.
 
@@ -88,6 +88,7 @@ static uint32_t (*do_read_32) (unsigned
 static void (*write_32) (unsigned char *ptr, GElf_Addr val);
 
 static int ptr_size;
+static int cu_version;
 
 static inline uint16_t
 buf_read_ule16 (unsigned char *data)
@@ -213,16 +214,18 @@ static struct
 #define DEBUG_LINE	2
 #define DEBUG_ARANGES	3
 #define DEBUG_PUBNAMES	4
-#define DEBUG_MACINFO	5
-#define DEBUG_LOC	6
-#define DEBUG_STR	7
-#define DEBUG_FRAME	8
-#define DEBUG_RANGES	9
+#define DEBUG_PUBTYPES	5
+#define DEBUG_MACINFO	6
+#define DEBUG_LOC	7
+#define DEBUG_STR	8
+#define DEBUG_FRAME	9
+#define DEBUG_RANGES	10
     { ".debug_info", NULL, NULL, 0, 0, 0 },
     { ".debug_abbrev", NULL, NULL, 0, 0, 0 },
     { ".debug_line", NULL, NULL, 0, 0, 0 },
     { ".debug_aranges", NULL, NULL, 0, 0, 0 },
     { ".debug_pubnames", NULL, NULL, 0, 0, 0 },
+    { ".debug_pubtypes", NULL, NULL, 0, 0, 0 },
     { ".debug_macinfo", NULL, NULL, 0, 0, 0 },
     { ".debug_loc", NULL, NULL, 0, 0, 0 },
     { ".debug_str", NULL, NULL, 0, 0, 0 },
@@ -302,7 +305,7 @@ no_memory:
         }
       if (*slot != NULL)
 	{
-	  error (0, 0, "%s: Duplicate DWARF-2 abbreviation %d", dso->filename,
+	  error (0, 0, "%s: Duplicate DWARF abbreviation %d", dso->filename,
 		 t->entry);
 	  free (t);
 	  htab_delete (h);
@@ -322,7 +325,7 @@ no_memory:
 	  form = read_uleb128 (ptr);
 	  if (form == 2 || form > DW_FORM_indirect)
 	    {
-	      error (0, 0, "%s: Unknown DWARF-2 DW_FORM_%d", dso->filename, form);
+	      error (0, 0, "%s: Unknown DWARF DW_FORM_%d", dso->filename, form);
 	      htab_delete (h);
 	      return NULL;
 	    }
@@ -332,7 +335,7 @@ no_memory:
         }
       if (read_uleb128 (ptr) != 0)
         {
-	  error (0, 0, "%s: DWARF-2 abbreviation does not end with 2 zeros",
+	  error (0, 0, "%s: DWARF abbreviation does not end with 2 zeros",
 		 dso->filename);
 	  htab_delete (h);
 	  return NULL;
@@ -441,16 +444,24 @@ has_prefix (const char  *str,
 {
   size_t str_len;
   size_t prefix_len;
-  
+
   str_len = strlen (str);
   prefix_len = strlen (prefix);
 
   if (str_len < prefix_len)
     return 0;
-  
+
   return strncmp (str, prefix, prefix_len) == 0;
 }
 
+static int dirty_elf;
+static void
+dirty_section (unsigned int sec)
+{
+  elf_flagdata (debug_sections[sec].elf_data, ELF_C_SET, ELF_F_DIRTY);
+  dirty_elf = 1;
+}
+
 static int
 edit_dwarf2_line (DSO *dso, uint32_t off, char *comp_dir, int phase)
 {
@@ -465,9 +476,9 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 
   if (phase != 0)
     return 0;
-  
+
   ptr += off;
-  
+
   endcu = ptr + 4;
   endcu += read_32 (ptr);
   if (endcu == ptr + 0xffffffff)
@@ -484,13 +495,13 @@ edit_dwarf2_line (DSO *dso, uint32_t off
     }
 
   value = read_16 (ptr);
-  if (value != 2)
+  if (value != 2 && value != 3)
     {
       error (0, 0, "%s: DWARF version %d unhandled", dso->filename,
 	     value);
       return 1;
     }
-  
+
   endprol = ptr + 4;
   endprol += read_32 (ptr);
   if (endprol > endcu)
@@ -499,10 +510,10 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 	     dso->filename);
       return 1;
     }
-  
+
   opcode_base = ptr[4];
   ptr = dir = ptr + 4 + opcode_base;
-  
+
   /* dir table: */
   value = 1;
   while (*ptr != 0)
@@ -597,12 +608,12 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 	}
 
       free (s);
-      
+
       read_uleb128 (ptr);
       read_uleb128 (ptr);
     }
   ++ptr;
-  
+
   if (dest_dir)
     {
       unsigned char *srcptr, *buf = NULL;
@@ -625,14 +636,16 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 	  size_t len = strlen ((char *)srcptr) + 1;
 	  const unsigned char *readptr = srcptr;
 
+	  char *orig = strdup ((const char *) srcptr);
+
 	  if (*srcptr == '/' && has_prefix ((char *)srcptr, base_dir))
 	    {
 	      if (dest_len < base_len)
-		  ++abs_dir_cnt;
+		++abs_dir_cnt;
 	      memcpy (ptr, dest_dir, dest_len);
 	      ptr += dest_len;
 	      readptr += base_len;
-		}
+	    }
 	  srcptr += len;
 
 	  shrank += srcptr - readptr;
@@ -641,9 +654,10 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 	  shrank -= len;
 	  ptr += len;
 
-	      elf_flagdata (debug_sections[DEBUG_STR].elf_data,
-			    ELF_C_SET, ELF_F_DIRTY);
-	    }
+	  if (memcmp (orig, ptr - len, len))
+	    dirty_section (DEBUG_STR);
+	  free (orig);
+	}
 
       if (shrank > 0)
 	{
@@ -651,7 +665,7 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 	    error (EXIT_FAILURE, 0,
 		   "canonicalization unexpectedly shrank by one character");
 	  else
-	    {	    
+	    {
 	      memset (ptr, 'X', shrank);
 	      ptr += shrank;
 	      *ptr++ = '\0';
@@ -663,7 +677,7 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 	  size_t len = (abs_dir_cnt + abs_file_cnt) * (base_len - dest_len);
 
 	  if (len == 1)
-	    error (EXIT_FAILURE, 0, "-b arg has to be either the same length as -d arg, or more than 1 char shorter");
+	    error (EXIT_FAILURE, 0, "-b arg has to be either the same length as -d arg, or more than 1 char longer");
 	  memset (ptr, 'X', len - 1);
 	  ptr += len - 1;
 	  *ptr++ = '\0';
@@ -684,8 +698,7 @@ edit_dwarf2_line (DSO *dso, uint32_t off
 			   len - base_len);
 		  ptr += dest_len - base_len;
 		}
-	      elf_flagdata (debug_sections[DEBUG_STR].elf_data,
-			    ELF_C_SET, ELF_F_DIRTY);
+	      dirty_section (DEBUG_STR);
 	    }
 	  else if (ptr != srcptr)
 	    memmove (ptr, srcptr, len);
@@ -705,8 +718,6 @@ edit_dwarf2_line (DSO *dso, uint32_t off
   return 0;
 }
 
-
-
 static unsigned char *
 edit_attributes (DSO *dso, unsigned char *ptr, struct abbrev_tag *t, int phase)
 {
@@ -714,7 +725,7 @@ edit_attributes (DSO *dso, unsigned char
   uint32_t list_offs;
   int found_list_offs;
   char *comp_dir;
-  
+
   comp_dir = NULL;
   list_offs = 0;
   found_list_offs = 0;
@@ -723,7 +734,6 @@ edit_attributes (DSO *dso, unsigned char
       uint32_t form = t->attr[i].form;
       size_t len = 0;
       size_t base_len, dest_len;
-      
 
       while (1)
 	{
@@ -737,56 +747,53 @@ edit_attributes (DSO *dso, unsigned char
 	    }
 
 	  if (t->attr[i].attr == DW_AT_comp_dir)
-	  {
-	      if ( form == DW_FORM_string )
-	      {
+	    {
+	      if (form == DW_FORM_string)
+		{
 		  free (comp_dir);
 		  comp_dir = strdup ((char *)ptr);
-		  
+
 		  if (phase == 1 && dest_dir && has_prefix ((char *)ptr, base_dir))
-		  {
+		    {
 		      base_len = strlen (base_dir);
 		      dest_len = strlen (dest_dir);
-		      
+
 		      memcpy (ptr, dest_dir, dest_len);
 		      if (dest_len < base_len)
-		      {
+			{
 			  memset(ptr + dest_len, '/',
 				 base_len - dest_len);
-			  
-		      }
-		      elf_flagdata (debug_sections[DEBUG_INFO].elf_data,
-				    ELF_C_SET, ELF_F_DIRTY);
-		  }
-	      }
-	  
+
+			}
+		      dirty_section (DEBUG_INFO);
+		    }
+		}
 	      else if (form == DW_FORM_strp &&
 		       debug_sections[DEBUG_STR].data)
-	      {
+		{
 		  char *dir;
 
 		  dir = (char *) debug_sections[DEBUG_STR].data
-		      + do_read_32_relocated (ptr);
+		    + do_read_32_relocated (ptr);
 
 		  free (comp_dir);
 		  comp_dir = strdup (dir);
 
 		  if (phase == 1 && dest_dir && has_prefix (dir, base_dir))
-		  {
+		    {
 		      base_len = strlen (base_dir);
 		      dest_len = strlen (dest_dir);
-		  
+
 		      memcpy (dir, dest_dir, dest_len);
 		      if (dest_len < base_len)
-		      {
+			{
 			  memmove (dir + dest_len, dir + base_len,
 				   strlen (dir + base_len) + 1);
-		      }
-		      elf_flagdata (debug_sections[DEBUG_STR].elf_data,
-				    ELF_C_SET, ELF_F_DIRTY);
-		  }
-	      }
-	  }
+			}
+		      dirty_section (DEBUG_STR);
+		    }
+		}
+	    }
 	  else if ((t->tag == DW_TAG_compile_unit
 		    || t->tag == DW_TAG_partial_unit)
 		   && t->attr[i].attr == DW_AT_name
@@ -794,9 +801,9 @@ edit_attributes (DSO *dso, unsigned char
 		   && debug_sections[DEBUG_STR].data)
 	    {
 	      char *name;
-	      
+
 	      name = (char *) debug_sections[DEBUG_STR].data
-		     + do_read_32_relocated (ptr);
+		+ do_read_32_relocated (ptr);
 	      if (*name == '/' && comp_dir == NULL)
 		{
 		  char *enddir = strrchr (name, '/');
@@ -815,21 +822,25 @@ edit_attributes (DSO *dso, unsigned char
 		{
 		  base_len = strlen (base_dir);
 		  dest_len = strlen (dest_dir);
-		  
+
 		  memcpy (name, dest_dir, dest_len);
 		  if (dest_len < base_len)
 		    {
 		      memmove (name + dest_len, name + base_len,
 			       strlen (name + base_len) + 1);
 		    }
-		  elf_flagdata (debug_sections[DEBUG_STR].elf_data,
-				ELF_C_SET, ELF_F_DIRTY);
+		  dirty_section (DEBUG_STR);
 		}
 	    }
 
 	  switch (form)
 	    {
-	    case DW_FORM_ref_addr: /* ptr_size in DWARF 2, offset in DWARF 3 */
+	    case DW_FORM_ref_addr:
+	      if (cu_version == 2)
+		ptr += ptr_size;
+	      else
+		ptr += 4;
+	      break;
 	    case DW_FORM_addr:
 	      ptr += ptr_size;
 	      break;
@@ -881,14 +892,14 @@ edit_attributes (DSO *dso, unsigned char
 	      assert (len < UINT_MAX);
 	      break;
 	    default:
-	      error (0, 0, "%s: Unknown DWARF-2 DW_FORM_%d", dso->filename,
+	      error (0, 0, "%s: Unknown DWARF DW_FORM_%d", dso->filename,
 		     form);
 	      return NULL;
 	    }
 
 	  if (form == DW_FORM_block1)
 	    ptr += len;
-	  
+
 	  break;
 	}
     }
@@ -977,7 +988,7 @@ edit_dwarf2 (DSO *dso)
 		      return 1;
 		    }
 
-		  scn = dso->scn[i]; 
+		  scn = dso->scn[i];
 		  data = elf_rawdata (scn, NULL);
 		  assert (data != NULL && data->d_buf != NULL);
 		  assert (elf_rawdata (scn, data) == NULL);
@@ -1053,7 +1064,7 @@ edit_dwarf2 (DSO *dso)
 	  int rtype;
 
 	  i = debug_sections[DEBUG_INFO].relsec;
-	  scn = dso->scn[i]; 
+	  scn = dso->scn[i];
 	  data = elf_getdata (scn, NULL);
 	  assert (data != NULL && data->d_buf != NULL);
 	  assert (elf_getdata (scn, data) == NULL);
@@ -1171,54 +1182,54 @@ edit_dwarf2 (DSO *dso)
 		  error (0, 0, "%s: 64-bit DWARF not supported", dso->filename);
 		  return 1;
 		}
-	      
+
 	      if (endcu > endsec)
 		{
 		  error (0, 0, "%s: .debug_info too small", dso->filename);
 		  return 1;
 		}
-	      
-	      value = read_16 (ptr);
-	      if (value != 2)
+
+	      cu_version = read_16 (ptr);
+	      if (cu_version != 2 && cu_version != 3)
 		{
 		  error (0, 0, "%s: DWARF version %d unhandled", dso->filename,
-			 value);
+			 cu_version);
 		  return 1;
 		}
-	      
+
 	      value = read_32_relocated (ptr);
 	      if (value >= debug_sections[DEBUG_ABBREV].size)
 		{
 		  if (debug_sections[DEBUG_ABBREV].data == NULL)
 		    error (0, 0, "%s: .debug_abbrev not present", dso->filename);
 		  else
-		    error (0, 0, "%s: DWARF-2 CU abbrev offset too large",
+		    error (0, 0, "%s: DWARF CU abbrev offset too large",
 			   dso->filename);
 		  return 1;
 		}
-	      
+
 	      if (ptr_size == 0)
 		{
 		  ptr_size = read_1 (ptr);
 		  if (ptr_size != 4 && ptr_size != 8)
 		    {
-		      error (0, 0, "%s: Invalid DWARF-2 pointer size %d",
+		      error (0, 0, "%s: Invalid DWARF pointer size %d",
 			     dso->filename, ptr_size);
 		      return 1;
 		    }
 		}
 	      else if (read_1 (ptr) != ptr_size)
 		{
-		  error (0, 0, "%s: DWARF-2 pointer size differs between CUs",
+		  error (0, 0, "%s: DWARF pointer size differs between CUs",
 			 dso->filename);
 		  return 1;
 		}
-	      
+
 	      abbrev = read_abbrev (dso,
 				    debug_sections[DEBUG_ABBREV].data + value);
 	      if (abbrev == NULL)
 		return 1;
-	      
+
 	      while (ptr < endcu)
 		{
 		  tag.entry = read_uleb128 (ptr);
@@ -1227,23 +1238,23 @@ edit_dwarf2 (DSO *dso)
 		  t = htab_find_with_hash (abbrev, &tag, tag.entry);
 		  if (t == NULL)
 		    {
-		      error (0, 0, "%s: Could not find DWARF-2 abbreviation %d",
+		      error (0, 0, "%s: Could not find DWARF abbreviation %d",
 			     dso->filename, tag.entry);
 		      htab_delete (abbrev);
 		      return 1;
 		    }
-		  
+
 		  ptr = edit_attributes (dso, ptr, t, phase);
 		  if (ptr == NULL)
 		    break;
 		}
-	      
+
 	      htab_delete (abbrev);
 	    }
 	}
       free (relbuf);
     }
-  
+
   return 0;
 }
 
@@ -1306,7 +1317,7 @@ fdopen_dso (int fd, const char *name)
     }
 
   elf_flagelf (elf, ELF_C_SET, ELF_F_LAYOUT);
-  
+
   memset (dso, 0, sizeof(DSO));
   dso->elf = elf;
   dso->ehdr = ehdr;
@@ -1360,6 +1371,9 @@ handle_build_id (DSO *dso, Elf_Data *bui
       exit (1);
     }
 
+  if (!dirty_elf)
+    goto print;
+
   if (elf_update (dso->elf, ELF_C_NULL) < 0)
     {
       fprintf (stderr, "Failed to update file: %s\n",
@@ -1439,6 +1453,7 @@ handle_build_id (DSO *dso, Elf_Data *bui
 
   elf_flagdata (build_id, ELF_C_SET, ELF_F_DIRTY);
 
+ print:
   /* Now format the build ID bits in hex to print out.  */
   {
     const uint8_t * id = (uint8_t *)build_id->d_buf + build_id_offset;
@@ -1463,7 +1478,7 @@ main (int argc, char *argv[])
   size_t build_id_offset = 0, build_id_size = 0;
 
   optCon = poptGetContext("debugedit", argc, (const char **)argv, optionsTable, 0);
-  
+
   while ((nextopt = poptGetNextOpt (optCon)) > 0 || nextopt == POPT_ERROR_BADOPT)
     /* do nothing */ ;
 
@@ -1475,7 +1490,7 @@ main (int argc, char *argv[])
 	      argv[0]);
       exit (1);
     }
-  
+
   args = poptGetArgs (optCon);
   if (args == NULL || args[0] == NULL || args[1] != NULL)
     {
@@ -1492,7 +1507,7 @@ main (int argc, char *argv[])
 	}
       if (strlen (dest_dir) > strlen (base_dir))
 	{
-	  fprintf (stderr, "Only dest dir longer than base dir not supported\n");
+	  fprintf (stderr, "Dest dir longer than base dir is not supported\n");
 	  exit (1);
 	}
     }
@@ -1514,12 +1529,12 @@ main (int argc, char *argv[])
       free (dest_dir);
       dest_dir = p;
     }
-  
+
   if (list_file != NULL)
     {
       list_file_fd = open (list_file, O_WRONLY|O_CREAT|O_APPEND, 0644);
     }
-  
+
   file = args[0];
 
   if (elf_version(EV_CURRENT) == EV_NONE)
@@ -1551,7 +1566,7 @@ main (int argc, char *argv[])
   for (i = 1; i < dso->ehdr.e_shnum; i++)
     {
       const char *name;
-      
+
       switch (dso->shdr[i].sh_type)
 	{
 	case SHT_PROGBITS:
@@ -1580,7 +1595,7 @@ main (int argc, char *argv[])
 	      Elf_Data src = dst;
 	      src.d_buf = data->d_buf;
 	      assert (sizeof (Elf32_Nhdr) == sizeof (Elf64_Nhdr));
-	      while ((char *) data->d_buf + data->d_size - 
+	      while ((char *) data->d_buf + data->d_size -
 		     (char *) src.d_buf > (int) sizeof nh
 		     && elf32_xlatetom (&dst, &src, dso->ehdr.e_ident[EI_DATA]))
 		{
@@ -1591,7 +1606,7 @@ main (int argc, char *argv[])
 		      && !memcmp ((char *) src.d_buf + sizeof nh, "GNU", sizeof "GNU"))
 		    {
 		      build_id = data;
-		      build_id_offset = (char *) src.d_buf + len - 
+		      build_id_offset = (char *) src.d_buf + len -
 					(char *) data->d_buf;
 		      build_id_size = nh.n_descsz;
 		      break;
@@ -1625,7 +1640,7 @@ main (int argc, char *argv[])
 
   /* Restore old access rights */
   chmod (file, stat_buf.st_mode);
-  
+
   poptFreeContext (optCon);
 
   return 0;
